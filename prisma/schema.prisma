generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Event {
  eventUuid       String      @id @default(uuid())
  time            Int
  action          EventAction
  position        Position
  points          Int
  quantity        Int?
  scoutReportUuid String
  scoutReport     ScoutReport @relation(fields: [scoutReportUuid], references: [uuid], onDelete: Cascade)

  @@index([scoutReportUuid])
}

model FeatureToggle {
  feature String  @id
  enabled Boolean @default(true)
}

model TeamMatchData {
  key           String        @id
  tournamentKey String
  matchNumber   Int           @db.SmallInt
  teamNumber    Int
  matchType     MatchType
  scoutReports  ScoutReport[]
  tournament    Tournament    @relation(fields: [tournamentKey], references: [key], onDelete: Cascade)

  @@index([tournamentKey, teamNumber])
}

model MutablePicklist {
  uuid          String      @id @default(uuid())
  teams         Int[]
  authorId      String
  name          String
  tournamentKey String?
  author        User        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  tournament    Tournament? @relation(fields: [tournamentKey], references: [key])
}

model ScoutReport {
  uuid                  String        @id @default(uuid())
  teamMatchKey          String
  startTime             DateTime
  notes                 String
  robotRoles            RobotRole[]
  driverAbility         Int
  scouterUuid           String
  robotBrokeDescription String?
  events                Event[]
  scouter               Scouter       @relation(fields: [scouterUuid], references: [uuid], onDelete: Cascade)
  teamMatchData         TeamMatchData @relation(fields: [teamMatchKey], references: [key], onDelete: Cascade)

  // year specific fields
  accuracy             Int
  beached              Beached
  climbPosition        ClimbPosition?
  climbSide            ClimbSide?
  defenseEffectiveness Int
  feederTypes          FeederType[]
  intakeType           IntakeType
  fieldTraversal       FieldTraversal
  scoresWhileMoving    Boolean
  disrupts             Boolean
  endgameClimb         EndgameClimb
  autoClimb            AutoClimb
}

model ScouterScheduleShift {
  uuid                    String         @id @default(uuid())
  sourceTeamNumber        Int
  tournamentKey           String
  startMatchOrdinalNumber Int
  endMatchOrdinalNumber   Int
  sourceTeam              RegisteredTeam @relation(fields: [sourceTeamNumber], references: [number], onDelete: Cascade)
  tournament              Tournament     @relation(fields: [tournamentKey], references: [key], onDelete: Cascade)
  team1                   Scouter[]      @relation("Team1")
  team2                   Scouter[]      @relation("Team2")
  team3                   Scouter[]      @relation("Team3")
  team4                   Scouter[]      @relation("Team4")
  team5                   Scouter[]      @relation("Team5")
  team6                   Scouter[]      @relation("Team6")
}

model Scouter {
  uuid               String                 @id @default(uuid())
  name               String?
  sourceTeamNumber   Int
  strikes            Int                    @default(0)
  scouterReliability Int                    @default(0)
  archived           Boolean                @default(false)
  scoutReports       ScoutReport[]
  sourceTeam         RegisteredTeam         @relation(fields: [sourceTeamNumber], references: [number], onDelete: Cascade)
  team1Shifts        ScouterScheduleShift[] @relation("Team1")
  team2Shifts        ScouterScheduleShift[] @relation("Team2")
  team3Shifts        ScouterScheduleShift[] @relation("Team3")
  team4Shifts        ScouterScheduleShift[] @relation("Team4")
  team5Shifts        ScouterScheduleShift[] @relation("Team5")
  team6Shifts        ScouterScheduleShift[] @relation("Team6")

  @@index([sourceTeamNumber])
}

model SharedPicklist {
  uuid                        String @id @default(uuid())
  name                        String
  totalPoints                 Float
  autoPoints                  Float
  teleopPoints                Float
  authorId                    String
  autoClimb                   Float
  campingDefenseTime          Float
  climbResult                 Float
  contactDefenseTime          Float
  driverAbility               Float
  defenseEffectiveness        Float
  estimatedSuccessfulFuelRate Float
  estimatedTotalFuelScored    Float
  feedingRate                 Float
  scoringRate                 Float
  totalDefensiveTime          Float
  totalFuelFed                Float
  totalFuelThroughput         Float
  author                      User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model Team {
  number         Int             @id
  name           String
  registeredTeam RegisteredTeam?
}

model RegisteredTeam {
  number                Int                    @id
  code                  String                 @unique
  email                 String
  emailVerified         Boolean                @default(false)
  teamApproved          Boolean                @default(false)
  website               String?
  team                  Team                   @relation(fields: [number], references: [number], onDelete: Cascade)
  scouters              Scouter[]
  scouterScheduleShifts ScouterScheduleShift[]
  slackChannels         SlackWorkspace[]
  users                 User[]
}

model EmailVerificationRequest {
  verificationCode String   @id
  email            String
  expiresAt        DateTime
  teamNumber       Int
}

model SlackWorkspace {
  workspaceId   String              @id
  owner         Int
  name          String
  authToken     String
  botUserId     String
  authUserId    String
  subscriptions SlackSubscription[]
  team          RegisteredTeam      @relation(fields: [owner], references: [number], onDelete: Cascade)
}

model SlackSubscription {
  subscriptionId      String                    @id
  channelId           String
  workspaceId         String
  subscribedEvent     WarningType
  notificationRecords SlackNotificationThread[]
  workspace           SlackWorkspace            @relation(fields: [workspaceId], references: [workspaceId], onDelete: Cascade)
}

model SlackNotificationThread {
  messageId      String            @id
  matchNumber    Int
  teamNumber     Int
  subscriptionId String
  channelId      String
  channel        SlackSubscription @relation(fields: [subscriptionId], references: [subscriptionId], onDelete: Cascade)
}

model Tournament {
  key                   String                 @id
  name                  String
  location              String?
  date                  String?
  mutablePicklists      MutablePicklist[]
  scouterScheduleShifts ScouterScheduleShift[]
  teamMatchData         TeamMatchData[]
}

model User {
  id                   String            @id
  teamNumber           Int?
  email                String            @unique
  emailVerified        Boolean           @default(false)
  username             String?
  role                 UserRole          @default(ANALYST)
  teamSourceRule       Json              @default("{\"mode\": \"EXCLUDE\", \"items\": []}")
  tournamentSourceRule Json              @default("{\"mode\": \"EXCLUDE\", \"items\": []}")
  ApiKeys              ApiKey[]
  mutablePicklists     MutablePicklist[]
  sharedPicklists      SharedPicklist[]
  team                 RegisteredTeam?   @relation(fields: [teamNumber], references: [number], onDelete: Cascade)
}

model ApiKey {
  uuid      String    @id @unique @default(uuid())
  keyHash   String    @unique
  name      String
  userId    String
  createdAt DateTime  @default(now())
  lastUsed  DateTime?
  requests  Int       @default(0)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CachedAnalysis {
  key                    String   @id
  teamDependencies       Int[]    @default([])
  tournamentDependencies String[] @default([])
}

enum Position {
  LEFT_TRENCH
  LEFT_BUMP
  HUB
  RIGHT_TRENCH
  RIGHT_BUMP
  NEUTRAL_ZONE
  DEPOT
  OUTPOST
  NONE
}

enum EventAction {
  START_SCORING
  STOP_SCORING
  START_MATCH
  START_CAMPING
  STOP_CAMPING
  START_DEFENDING
  STOP_DEFENDING
  INTAKE
  OUTTAKE
  DISRUPT
  CROSS
  CLIMB
  START_FEEDING
  STOP_FEEDING
}

enum FieldTraversal {
  TRENCH
  BUMP
  BOTH
  NONE
}

enum Beached {
  ON_FUEL
  ON_BUMP
  BOTH
  NEITHER
}

enum EndgameClimb {
  NOT_ATTEMPTED
  FAILED
  L1
  L2
  L3
}

enum ClimbPosition {
  SIDE
  MIDDLE
}

enum ClimbSide {
  FRONT
  BACK
}

enum AutoClimb {
  NOT_ATTEMPTED
  FAILED
  SUCCEEDED
}

enum FeederType {
  CONTINUOUS
  STOP_TO_SHOOT
  DUMP
}

enum IntakeType {
  GROUND
  OUTPOST
  BOTH
  NEITHER
}

enum RobotRole {
  CYCLING
  SCORING
  FEEDING
  DEFENDING
  IMMOBILE
}

enum WarningType {
  BREAK
}

enum UserRole {
  ANALYST
  SCOUTING_LEAD
}

enum MatchType {
  QUALIFICATION
  ELIMINATION
}
